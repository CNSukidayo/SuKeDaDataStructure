# 绪论
### &emsp;&emsp;当我们谈论起算法时总是无法脱离数据结构的,实际上数据结构与算法这两者是相辅相成的,只有数据结构才能彰显算法的强大,只有算法才能突出数据结构的魅力!所以除了算法之外我也会对常见的数据结构进行实现.
### <p align="right">一一顾元杰</br>学号:20200135223</br>班级:计算机Z2012</p>

# 目录:
##### <p align="right">提示:点击题目名称可直接跳转LeetCode</p>
* ### [剑指 Offer 03. 数组中重复的数字](#Offer03)
* ### [剑指 Offer II 004. 只出现一次的数字 ](#Offer04)
* ### [707. 设计链表](#Leetcode707)
</br>

## <a id="dataStructure">常用数据结构:</a>  
* ### [链表](#LinkList)
</br>

## <a id="skill">常见技巧总结:</a>  
* ### [代码的健壮性](#Robust)
* ### [开辟额外空间的注意事项](#extraCache)
* ### [得到十进制数的第i位二进制表示](#HexToBitArray)

</br>
  
## <a id="Offer03">[剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)</a>  

### **<font color="#dddd00">题目描述:</font>**
> 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>>示例 1：  
输入：
[2, 3, 1, 0, 2, 5, 3]  
输出：2 或 3  
>  
> >  限制：  
2 <= n <= 100000

### **<font color="#00FF00">解题思路:</font>**
1. ### 根据题目所述,nums数组中所有元素的范围都在[0,n-1]的范围内.于是乎自然相当,可以用一个长度为n的布尔数组contains来存储当前已经出现的元素的真假.用contains数组的索引来对应元素字面值.
2. ### 首先初始化contains数组,长度为n.此时contains数组中的每个元素都为false.
3. ### 接着遍历nums数组,直接以nums数组中元素的字面值作为contains数组的元素索引,将该索引处的元素值设置为true,以此来代表某个数已经出现过.
4. ### 如果在遍历的过程中,发现在设置contains数组的某个元素值为true之前,该元素值已经是true了,那么就表明当前数已经出现过一次,返回即可.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.public int findRepeatNumber(int[] nums) {
2.    if (nums == null || nums.length == 0) {
3.        throw new IllegalArgumentException("parameter should not be null or empty!");
4.    }
5.    boolean[] contains = new boolean[nums.length];
6.    for (int i = 0; i < nums.length; i++) {
7.        if (temp[nums[i]]) {
8.            return nums[i];
9.        }
10.        contains[nums[i]] = true;
11.    }
12.    return 0;
13.}

```
1. ### 首先是代码健壮性的判断.2-4行,关于代码健壮性判断详情见:[代码的健壮性](#Robust)
2. ### 第五行是用于存储已经出现过的元素的状态标识数组.数组的索引映射出现过的元素的字面值.
3. ### 6-11行遍历nums数组,并做相应的操作.

### **<font color="#FF00FF">表格演示:</font>**
1. ### 初始化contains数组,长度为n.
|    ↓     |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  array   |   2   |   3   |   1   |   0   |   2   |   5   |   3   |
| contains |   F   |   F   |   F   |   F   |   F   |   F   |   F   |
2. ### 开始遍历数组
### 将array当前元素的字面值作为contains数组的下标,并将该contains元素设置为true.
|  index   | <strong><font color="#ff00ff">↓</font></strong> |   1   |                        2                        |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|  array   | <strong><font color="#00ff00">2</font></strong> |   3   |                        1                        |   0   |   2   |   5   |   6   |
| contains |                        F                        |   F   | <strong><font color="#00ff00">F</font></strong> |   F   |   F   |   F   |   F   |
3. ### 继续遍历执行
|  index   |                        0                        | <strong><font color="#ff00ff">↓</font></strong> |                        2                        |                        3                        |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                        1                        |                        0                        |   2   |   5   |   6   |
| contains |                        F                        |                        F                        | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#00ff00">F</font></strong> |   F   |   F   |   F   |

4. ### 继续遍历执行
|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |                        3                        |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#00ff00">1</font></strong> |                        0                        |   2   |   5   |   6   |
| contains |                        F                        | <strong><font color="#00ff00">F</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |   T   |   F   |   F   |
5. ### 继续遍历执行
|  index   |                        0                        |                        1                        |                        2                        | <strong><font color="#ff00ff">↓</font></strong> |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">0</font></strong> |   2   |   5   |   6   |
| contains | <strong><font color="#00ff00">F</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |   T   |   F   |   F   |
6. ### 继续遍历执行,直到访问到contains数组某个元素为true时,此时array数组的当前元素就是重复出现过的元素.所以此时2即为重复出现的元素.
|  index   |                        0                        |                        1                        |                        2                        |                        3                        | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">0</font></strong> | <strong><font color="#00ff00">2</font></strong> |   5   |   6   |
| contains | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ff0000">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |                        T                        |   F   |   F   |

**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > ### 假设一种最坏的情况,数组中元素只重复出现一次,例如:[0,1,2,3,...n-1,0],因为需要遍历玩整个数组才知道重复的元素是哪一个,所以时间复杂是O(n).

> ### 空间复杂度:O(n)
> > ### 因为需要一个布尔数组contains数组来存放已经出现过的元素的状态值,并且认定出现过的数作为contains数组的下标,那么要想contains下标合法,所以contains数组的长度就是元素数值的取值范围.即n-1+1=n
> > ### 最后检验,发现给出的条件中有<font color="#FF0000">2<=n<=100000</font>,contains数组大小不超过2^31-1.
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer3.png)

## <a id="Offer04">[剑指 Offer II 004. 只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)</a>  
### **<font color="#dddd00">题目描述:</font>**
> ### 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
> ### 示例 1：
> > ### 输入：nums = [2,2,3,2]
> > ### 输出：3
> ### 示例 2：
> > ### 输入：nums = [0,1,0,1,0,1,100]
> > ### 输出：100
> ### 提示：
> > * ### 1 <= nums.length <= 3 * 10<sup>4</sup>
> > * ### -2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1
> > * ### nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
## <p align="center"><font color="#0000FF">解法一之双HashSet</font></p>
### **<font color="#00FF00">解题思路:</font>**
1. ### 在本题给出的条件中,nums数组的每个元素的取值范围为-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1,显然我们不可能按照Offer3那题的方法去创建一个布尔数组标识已经出现过的数的状态,因为nums数组中元素的取值范围太广泛.
2. ### 既然如此,题目中又说除了某个元素外其余的元素都恰好出现三次.显然我们可以通过另一种方式来标识已经出现过的元素.
3. ### 我们解题的核心技术扣住某个元素只出现一次这句话.创建两个HastSet一个称作contains,contains的作用是记录所有出现过元素,即只要某个元素不存在于contains中,那么就将该元素添加到contains集合中.第二个HastSet称作saveSet,saveSet的作用是记录已经出现过的元素,并将重复的元素从saveSet中移除.
4. ### 首先遍历nums数组,将每个元素去contains集合中进行比对看contains集合是否有该元素,如果没有就将该元素添加到contains和saveSet集合中.如果contains元素中有该元素,则能传递两个信息,一是该元素曾经必然出现过,二是saveSet中曾经也必然添加过该元素,于是乎这是一个重复元素将该元素从saveSet中移除.如此操作所有重复出现过的元素到最后必然都不存在于saveSet中,只有那个只出现过一次的元素会存在于saveSet中,最终将该元素返回即刻.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.public class Offer4 {
2.    private Set<Integer> saveSet;
3.    private Set<Integer> contains;
4.
5.    public int singleNumber(int[] nums) {
6.        if (nums == null || nums.length % 3 != 1) {
7.            throw new IllegalArgumentException("nums数组不能为空,并且nums数组的长度取余3必须为1!");
8.        }
9.        saveSet = new HashSet<>(nums.length / 3 + 1);
10.       contains = new HashSet<>(nums.length / 3 + 1);
11.        for (int i = 0; i < nums.length; i++) {
12.            if (!contains.contains(nums[i])) {
13.                contains.add(nums[i]);
14.                saveSet.add(nums[i]);
15.            } else {
16.                saveSet.remove(nums[i]);
17.            }
18.        }
19.        return saveSet.iterator().next();
20.    }
21.}
```
1. ### 首先6-8行是代码健壮性的判断,详情见:[代码的健壮性.](#Robust)另外值得注意的一点是,这里数组的长度取模3的值一定是1,因为除某个元素只出现一次外,其余的每个元素都恰好出现三次.
2. ### 9-10行对HashSet进行初始化,并且指定集合大小,saveSet指定为nums.length / 3 + 1,具体为什么是这个值的原因不在过多阐述.提前指定集合大小的好处是避免HastSet的自动扩容造成的时间和空间上的浪费.
3. ### 接着就是遍历nums数组,并按照解题思路中的思路编码即可.
4. ### 最后一步返回结果的时候,因为此时saveSet中必然只剩下一个元素(即只出现一次的元素),所以直接用迭代器返回第一个元素即刻.
### **<font color="#FF00FF">表格演示:</font>**
1. ### 以nums = [1,2,1,3,2,1,2]举例

2. ### 初始化HastSet
|  index   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   nums   |   1   |   2   |   1   |   3   |   2   |   1   |   2   |
| contains |       |       |       |       |       |       |       |
| saveSet  |       |       |       |       |       |       |       |

3. ### 开始遍历数组,并且在contains集合中进行判断看是否存在当前元素,如果不存在就将当前元素添加到contains和saveSet集合中去.
|  index   | <strong><font color="#ff00ff">↓</font></strong> |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---: | :---: | :---: | :---: | :---: | :---: |
|   nums   | <strong><font color="#00ff00">1</font></strong> |   2   |   1   |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#00ff00">1</font></strong> |       |       |       |       |       |       |
| saveSet  | <strong><font color="#00ff00">1</font></strong> |       |       |       |       |       |       |

4. ### 继续遍历
|  index   |                        0                        | <strong><font color="#ff00ff">↓</font></strong> |   2   |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        | <strong><font color="#00ff00">2</font></strong> |   1   |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> |       |       |       |       |       |
| saveSet  | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> |       |       |       |       |       |
5. ### 继续遍历,一旦发现contains数组中存在当前元素,那么就将当前元素从saveSet集合中移除.
|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        | <strong><font color="#00ff00">1</font></strong> |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#ffc800">2</font></strong> |                                                 |       |       |       |       |
| saveSet  | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#ffc800">2</font></strong> |                                                 |       |       |       |       |

|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        | <strong><font color="#00ff00">1</font></strong> |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> |                                                 |       |       |       |       |
| saveSet  | <strong><font color="#ffc800">2</font></strong> |                                                 |                                                 |       |       |       |       |
6. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        | <strong><font color="#ff00ff">↓</font></strong> |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        | <strong><font color="#00ff00">3</font></strong> |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                                                 |       |       |       |
| saveSet  | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                                                 |                                                 |       |       |       |
7. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        |   3   | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   | <strong><font color="#00ff00">2</font></strong> |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |                                                 |       |       |
| saveSet  | <strong><font color="#00ff00">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |                                                 |       |                                                 |       |       |

|  index   |                        0                        |                        1                        |                        2                        |   3   | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   | <strong><font color="#00ff00">2</font></strong> |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |                                                 |       |       |
| saveSet  | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |                                                 |       |       |

8. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        |   3   |   4   | <strong><font color="#ff00ff">↓</font></strong> |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---------------------------------------------: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   |   2   | <strong><font color="#00ff00">1</font></strong> |   2   |
| contains | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |       |                                                 |       |
| saveSet  | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |       |                                                 |       |

9. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        |   3   |   4   |   5   | <strong><font color="#ff00ff">↓</font></strong> |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---------------------------------------------: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   |   2   |   1   | <strong><font color="#00ff00">2</font></strong> |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |       |       |                                                 |
| saveSet  | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |       |       |                                                 |
 
10. ### 遍历结束后将saveSet中的第一个元素(也就是唯一的一个元素)返回即可.
|  index   |                        0                        |                        1                        |                        2                        |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |       |       |       |
| saveSet  | <strong><font color="#ff0000">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |       |       |       |


**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > 1. ### 首先需要遍历整个nums数组,所以时间复杂度为O(n)
> > 2. ### 其次每次都要对元素进行contains判断,根据主流说法,HashSet的时间复杂度为O(1).
> > 3. ### contains被判为false一共只会出现nums.length/3+1次,当contains判为false时会进行两次add操作,分别将当前元素添加到contains和saveSet这两个集合中去,根据主流说法HashSet的add方法时间复杂度为O(1),所以contains被判为false时会执行O(1)+O(1)的时间复杂度的代码.
> > 4. ### contains被判为true一共会出现num.length / 3 * 2次,当contains判为true时会对saveSet进行remove操作,根据主流说法HashSet的remove方法时间复杂度为O(1).
> > 5. ### 所以综上所述时间复杂度为:O(n*(O(1) + n / 3 + 1 * (O(1)+O(1)) + n / 3 * 2 * O(1))) = O(n)

> ### 空间复杂度:O(n)
> > 1. ### 需要两个HashSet,其中contains这个集合的大小为O(n / 3 + 1),因为不管给定的nums内的元素如何排列,contains集合代表的意义是已经出现过的元素的集合.而所有元素出现的次数必定是nums数组的总长度除3再加1.
> > 2. ### 同理saveSet集合也不会存储重复出现过的元素,所以它的长度最大也是nums数组的长度除3再加1.即O(n / 3 + 1)
> > 3. ### 综上所述空间复杂度为: O(n / 3 + 1) + O(n / 3 + 1) = O(n)

### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer4_1.png)

## <p align="center"><font color="#0000FF">解法二之排序</font></p>
### **<font color="#00FF00">解题思路:</font>**
1. ### 如题所述,解题核心是紧扣每个元素都恰好出现三次.
2. ### 我们先假设nums数组中的每个元素都恰好出现三次,此时对该数组进行排序后,应当形成每三个元素为一组的局面.每组元素都相同.若此时往该有序数组中插入一个未出现过的元素,那么这个元素出现的位置只也两种可能.第一种可能是出现在某组之前,另外一种可能是出现在nums数组的最后一个位置.
3. ### 看第一种情况,假设 nums = [1,3,1,3,1,3,2] 将其排序后 nums = [1,1,1,2,3,3,3].
4. ### 再看一种情况,假设 nums = [1,2,1,2,1,2,3] 将其排序后 nums = [1,1,1,2,2,2,3].
5. ### 所以我们只要每三个元素为一组进行遍历,遍历时判断每组的第一个和第二个元素是否相等,如果这两个元素不相等,那么该组中的第一个元素就是只出现一次的元素.对于第二种情况,如果遍历到最后只剩下一个元素时还没有找到只出现一次的元素,那么最后一个元素必为只出现一次的元素.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.class Solution {
2.    public int singleNumber(int[] nums) {
3.        if (nums == null || nums.length % 3 != 1) {
4.            throw new IllegalArgumentException("nums数组不能为空,并且nums数组的长度取余3必须为1!");
5.        }
6.        Arrays.sort(nums);
7.        for (int i = 0; i < nums.length - 1; i += 3) {
8.            if (nums[i] != nums[i + 1]) {
9.                return nums[i];
10.            }
11.        }
12.        return nums[nums.length - 1];
13.    }
14.}
```
1. ### 首先6-8行是代码健壮性的判断,详情见:[代码的健壮性.](#Robust)另外值得注意的一点是,这里数组的长度取模3的值一定是1,因为除某个元素只出现一次外,其余的每个元素都恰好出现三次.
2. ### 接着调用Arrays.sort()对nums数组进行排序.
3. ### 按照一开始的思路,对排序后的nums数组以三个元素为一组,对每组的第一个和第二个元素进行值相等的比较.
4. ### 如果for循环结束还没有找到只出现一次的数值,那么就将数组最后一个元素进行返回.
### **<font color="#FF00FF">表格演示:</font>**
1. ### 初始化表格
| index |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| nums  |   1   |   3   |   1   |   3   |   1   |   3   |   2   |
2. ### 对nums数组进行排序
| index |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| nums  |   1   |   1   |   1   |   2   |   3   |   3   |   3   |
3. ### 以三个元素为一组开始遍历,并比较第一个元素和第二个元素是否相等.
| index | <strong><font color="#ff00ff">↓</font></strong> | <strong><font color="#ff00ff">↓</font></strong> |   2   |   3   |   4   |   5   |   6   |
| :---: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: | :---: |
| nums  | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#00ff00">1</font></strong> |   1   |   2   |   3   |   3   |   3   |
4. ### 如果发现不相等,则返回改组中的第一个元素,注意因为是以三个元素为一组所以不会对索引2除的元素进行任何操作.这里发现2!=3所以返回2即刻.
| index |                        0                        |                        1                        |   2   | <strong><font color="#ff00ff">↓</font></strong> | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :---: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: |
| nums  | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">1</font></strong> |   1   | <strong><font color="#ff0000">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |   3   |   3   |
**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n log(n))
> > 1. ### 首先第一步就是对nums数组进行排序,根据JDK官方的API说法是该算法在大多数情况下的时间复杂度都是O(n log(n)),所以对nums数组进行排序的时间复杂度为O(n log(n)).
> > 2. ### 其次是以三个元素为一组进行比较,一共会执行 n / 3次,所以比较数值这一步的时间复杂度为O(n / 3)
> > 3. ### 综上所述,算法的时间复杂度为O(n log(n))
> ### 空间复杂度:O(1)
> > 1. ### 本算法不需要开辟额外的内存空间,所以空间复杂度为O(1),即本算法所消耗的空间大小不随问题规模的扩大而扩大.
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer4_2.png)

## <p align="center"><font color="#0000FF">解法三之位运算</font></p>

### **<font color="#00FF00">解题思路:</font>**
1. ### 上述两种算法都各有优劣,一个时间复杂度相对较低,一个空间复杂度相对较低.
2. ### 看了一眼这题的标签是位运算,那么就想想能否用位运算来优化这道题的算法.
3. ### 假设nums = [5,5,5] 这是一个每个元素重复出现三次的数组,它们的二进制分别是:
   ### 1 0 1</br> 
   ### 1 0 1</br>
   ### 1 0 1</br>
   ### 将这三个二进制的每一位想加,得到的二进制是3 0 3 我们对每一位取模3,得到的结果就是 0 0 0.
4. ### 假设nums = [5,5,5,3] 它们的二进制分别为:
   ### 1 0 1</br>
   ### 1 0 1</br>
   ### 1 0 1</br>
   ### &emsp;1 1</br>
   ### 将这四个二进制的每一位想加,得到的二进制是 3 1 4 同样对每一位进行取模3,得到的结果就是 0 1 1 此时不难发现该结果就是只出现一次元素的二进制值.
5. ### 会产生这种情况得益于数组中很多元素都是成3重复出现的,所以它们的二进制也会存在某种相似性(或者叫对称性),导致将它们的二进制表示想加后再取模3结果一定是0.而唯有那个只出现一次的元素的二进制值是显得突兀的.
6. ### 根据题目的提示,数组元素的取值范围为-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1 也就是说会出现负数的情况.而在Java中基本数据类型都是有符号的,并且最高位为符号位.0代表正数1代表负数,所以在相加每个数的二进制时通常要考虑符号位的问题.而这里由于负数和正数的符号位也存在一种对称的关系(即负数和正数出现的次数一定能被3整除,不包含只出现一次的数).简单来说就是这里只要把所有数的二进制想加即可.
7. ### 首先,我们要创建一个长度为32的short数组(称为plus),数组元素从0到32(0->32)依次表示十进制数的二进制从最高位到最低位.假设我们要讲十进制数3存入到plus数组中,它应该是这样的:
    | index |   0   |   1   | 2...29 |  30   |  31   |
    | :---: | :---: | :---: | :----: | :---: | :---: |
    | plus  |   0   |   0   | 0...0  |   1   |   1   |
    ### 值得注意的是将十进制数的二进制表示存储到plus数组中时要注意索引位置不是从0开始存储,而是从数组最后一个元素往前存储.
    ### 另外short类型也有讲究,因为这题给定nums数组的长度范围是<font color="#FF0000">1 <= nums.length <= 3 * 10^4</font>,所以就算nums数组中所有数的某一位二进制都是1,那么在这一位上一共也就是想加30000次,是在short类型的范围之内的.
8. ### 现在开始遍历nums数组,并拿到一个十进制元素.那么该如何将这个十进制元素的二进制表示,存放到plus数组中呢?换句话说就是如何得到十进制数的二进制表示的每一位的值?详情见:[得到十进制数的第i位二进制表示](#HexToBitArray)
9. ### 遍历完数组之后,就是将plus数组中的每个元素对3进行取模,取模后得到的数组就表示只出现一次的那个元素的二进制表示.最后一步就是将二进制数组转为十进制数,我们只要定义一个变量result,然后遍历plus数组将result每次都加等于plus元素的数组再讲其左移1位往复循环便可得到该二进制数组的十进制表示.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.class Solution {
2.    int[] plus = new int[32];
3.
4.    public int singleNumber(int[] nums) {
5.        if (nums == null || nums.length % 3 != 1) {
6.            throw new IllegalArgumentException("nums数组不能为空,并且nums数组的长度取余3必须为1!");
7.        }
8.        for (int i = 0; i < nums.length; i++) {
9.            int currentNumber = nums[i];
10.            for (int j = plus.length - 1; j > -1; j--) {
11.                if (currentNumber != 0) {
12.                    plus[j] += 1 & currentNumber;
13.                    currentNumber >>= 1;
14.                } else {
15.                    break;
16.                }
17.            }
18.        }
19.        for (int i = 0; i < plus.length; i++) {
20.            plus[i] %= 3;
21.        }
22.        int result = 0;
23.        for (int i = 0; i < plus.length; i++) {
24.            result <<= 1;
25.            result += plus[i];
26.        }
27.        return result;
28.    }
29.}
```
1. ### 第2行定义plus数组,长度为32因为int类型是4字节32位的,这里既然要用数组来表示每一位二进制,自然长度为32.
2. ### 5-7行依旧时代码健壮性的判断,详情见:[代码的健壮性.](#Robust)
3. ### 8-18行遍历nums数组并将每一位添加到plus数组中.
4. ### 19-21行,将plus数组的每一位取模3
5. ### 将二进制数组plus转为十进制数值.
### **<font color="#FF00FF">表格演示:</font>**
1. ### 初始化表格,假设nums = [1,-2,3,1,-2,-2,1]
|   index    |   0   |   1   |   2    |   3   |   4   |   5   |   6   |
| :--------: | :---: | :---: | :----: | :---: | :---: | :---: | :---: |
|    nums    |   1   |  -2   |   3    |   1   |  -2   |  -2   |   1   |
| plus index |   0   |   1   | 2...27 |  28   |  29   |  30   |  31   |
|    plus    |   0   |   0   |   0    |   0   |   0   |   0   |   0   |
2. ### 开始遍历数组,得到第一个元素1的二进制值为1
|   index    | <strong><font color="#ff00ff">↓</font></strong> |   1   |   2    |   3   |   4   |   5   |                        6                         |
| :--------: | :---------------------------------------------: | :---: | :----: | :---: | :---: | :---: | :----------------------------------------------: |
|    nums    | <strong><font color="#00ff00">1</font></strong> |  -2   |   3    |   1   |  -2   |  -2   |                        1                         |
| plus index |                        0                        |   1   | 2...27 |  28   |  29   |  30   | <strong><font color="#00ff00">31</font></strong> |
|    plus    |                        0                        |   0   |   0    |   0   |   0   |   0   | <strong><font color="#00ff00">1</font></strong>  |
3. ### 继续遍历数组,第二个元素-2的二进制值为1000......10注意这里是负数.
|   index    |                        0                        | <strong><font color="#ff00ff">↓</font></strong>  |   2    |   3   |   4   |                        5                         |                        6                         |
| :--------: | :---------------------------------------------: | :----------------------------------------------: | :----: | :---: | :---: | :----------------------------------------------: | :----------------------------------------------: |
|    nums    |                        1                        | <strong><font color="#00ff00">-2</font></strong> |   3    |   1   |  -2   |                        -2                        |                        1                         |
| plus index | <strong><font color="#00ff00">0</font></strong> |                        1                         | 2...27 |  28   |  29   | <strong><font color="#00ff00">30</font></strong> | <strong><font color="#ffc800">31</font></strong> |
|    plus    | <strong><font color="#00ff00">1</font></strong> |                        0                         |   0    |   0   |   0   |                        1                         | <strong><font color="#ffc800">1</font></strong>  |
4. ### 继续遍历数组,第三个元素3的二进制值为11
|   index    |                        0                        |   1   | <strong><font color="#ff00ff">↓</font></strong> |   3   |   4   |                        5                         |                        6                         |
| :--------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: | :----------------------------------------------: | :----------------------------------------------: |
|    nums    |                        1                        |  -2   | <strong><font color="#00ff00">3</font></strong> |   1   |  -2   |                        -2                        |                        1                         |
| plus index | <strong><font color="#ffc800">0</font></strong> |   1   |                     2...27                      |  28   |  29   | <strong><font color="#00ff00">30</font></strong> | <strong><font color="#00ff00">31</font></strong> |
|    plus    | <strong><font color="#ffc800">1</font></strong> |   0   |                        0                        |   0   |   0   | <strong><font color="#00ff00">2</font></strong>  | <strong><font color="#00ff00">2</font></strong>  |
5. ### 继续遍历,第四个元素1的二进制值为1
|   index    |                        0                        |   1   |   2    | <strong><font color="#ff00ff">↓</font></strong> |   4   |                        5                         |                        6                         |
| :--------: | :---------------------------------------------: | :---: | :----: | :---------------------------------------------: | :---: | :----------------------------------------------: | :----------------------------------------------: |
|    nums    |                        1                        |  -2   |   3    | <strong><font color="#00ff00">1</font></strong> |  -2   |                        -2                        |                        1                         |
| plus index | <strong><font color="#ffc800">0</font></strong> |   1   | 2...27 |                       28                        |  29   | <strong><font color="#ffc800">30</font></strong> | <strong><font color="#00ff00">31</font></strong> |
|    plus    | <strong><font color="#ffc800">1</font></strong> |   0   |   0    |                        0                        |   0   | <strong><font color="#ffc800">2</font></strong>  | <strong><font color="#00ff00">3</font></strong>  |
6. ### 继续遍历直到最后一个元素
|   index    |                        0                        |   1   |   2    |   3   |   4   |                        5                         | <strong><font color="#ff00ff">↓</font></strong>  |
| :--------: | :---------------------------------------------: | :---: | :----: | :---: | :---: | :----------------------------------------------: | :----------------------------------------------: |
|    nums    |                        1                        |  -2   |   3    |   1   |  -2   |                        -2                        | <strong><font color="#00ff00">1</font></strong>  |
| plus index | <strong><font color="#ffc800">0</font></strong> |   1   | 2...27 |  28   |  29   | <strong><font color="#ffc800">30</font></strong> | <strong><font color="#00ff00">31</font></strong> |
|    plus    | <strong><font color="#ffc800">3</font></strong> |   0   |   0    |   0   |   0   | <strong><font color="#ffc800">4</font></strong>  | <strong><font color="#00ff00">4</font></strong>  |
7. ### 对plus数组的每个元素对3进行取模.
|   index    |                        0                        |                        1                        |                        2                        |                        3                        |                        4                        |                        5                         | <strong><font color="#ff00ff">↓</font></strong>  |
| :--------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :----------------------------------------------: | :----------------------------------------------: |
|    nums    |                        1                        |                       -2                        |                        3                        |                        1                        |                       -2                        |                        -2                        | <strong><font color="#00ff00">1</font></strong>  |
| plus index | <strong><font color="#00ff00">0</font></strong> |                        1                        |                     2...27                      |                       28                        |                       29                        | <strong><font color="#00ff00">30</font></strong> | <strong><font color="#00ff00">31</font></strong> |
|    plus    | <strong><font color="#ff0000">0</font></strong> | <strong><font color="#ff0000">0</font></strong> | <strong><font color="#ff0000">0</font></strong> | <strong><font color="#ff0000">0</font></strong> | <strong><font color="#ff0000">0</font></strong> | <strong><font color="#ff0000">1</font></strong>  | <strong><font color="#ff0000">1</font></strong>  |
8. ### 将plus二进制数组转为十进制,最终的结果即为3是只出现一次的元素.

**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > 1. ### 首选需要遍历整个数组,并且对于数组的每个元素还要做32次的位运算(为了获取当前十进制数的二进制表示而做的运算),即时间复杂度为O(n*32)
> > 2. ### 遍历完nums数组后,还需要将当前plus数组的每一位元素对3进行取模,而plus数组的长度固定为32.所以时间复杂度为O(32)
> > 3. ### 最后还需要将plus数组再遍历一次,为的是将二进制数组转为十进制表示.所以时间复杂度也是O(32)
> > 4. ### 综上所述,时间复杂度为O(n * 32) + O(32) + O(32) = O(n) 
> ### 空间复杂度:O(1)
> > 1. ### 只开辟了一个长度固定为32的short数组,作为二进制数的存储.即空间复杂度为O(32) = O(1) 即算法的空间复杂度不随问规模的扩大而扩大.
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer4_3.png)

## <a id="Leetcode707">[707. 设计链表:](https://leetcode.cn/problems/design-linked-list/)</a>  
## 本题题解放到常用数据结构之链表中完成,[点击跳转](#LinkList).



## <p align="center"><font color="#0000FF">[常用数据结构](#dataStructure)</font></p>
## <a id="LinkList">链表:</a>
## <p align="right">[本题借用 LeetCode707.设计链表 作为链表数据结构实现的引入(点击跳转)](https://leetcode.cn/problems/design-linked-list/)</p>
### **<font color="#dddd00">题目描述:</font>**
> ### 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：<font color="#FF0000">val</font> 和 <font color="#FF0000">next</font>。<font color="#FF0000">val</font> 是当前节点的值，<font color="#FF0000">next</font> 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。  
> ### 在链表类中实现这些功能：  
> * ### get(index)：获取链表中第 <font color="#FF0000">index</font> 个节点的值。如果索引无效，则返回<font color="#FF0000">-1</font>。
> * ### addAtHead(val)：在链表的第一个元素之前添加一个值为<font color="#FF0000"> val</font> 的节点。插入后，新节点将成为链表的第一个节点。
> * ### addAtTail(val)：将值为 <font color="#FF0000">val</font> 的节点追加到链表的最后一个元素。
> * ### addAtIndex(index,val)：在链表中的第 <font color="#FF0000">index</font> 个节点之前添加值为 <font color="#FF0000">val</font>  的节点。如果 <font color="#FF0000">index</font> 等于链表的长度，则该节点将附加到链表的末尾。如果 <font color="#FF0000">index</font> 大于链表长度，则不会插入节点。如果<font color="#FF0000">index</font>小于0，则在头部插入节点。
> * ### deleteAtIndex(index)：如果索引 <font color="#FF0000">index</font> 有效，则删除链表中的第 <font color="#FF0000">index</font> 个节点。
> ### 示例:
> > ### MyLinkedList linkedList = new MyLinkedList();
> > ### linkedList.addAtHead(1);
> > ### linkedList.addAtTail(3);
> > ### linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
> > ### linkedList.get(1);            //返回2
> > ### linkedList.deleteAtIndex(1);  //现在链表是1-> 3
> > ### linkedList.get(1);            //返回3
> ### 提示:
> > * ### <font color="#FF0000">0 <= index, val <= 1000</font>
> > * ### 请不要使用内置的 LinkedList 库。
> > * ### <font color="#FF0000">get, addAtHead, addAtTail, addAtIndex 和 deleteAtIndex</font> 的操作次数不超过 2000。
### **<p align="center"><font color="#FF0000">什么是链表?</font></p>**
1. ### 链表和顺序表都隶属于线性表,都是用来存放数据的,但是链表和顺序表有很多的区别(这里先特指单链表).
2. ### 不像顺序表需要在内存中开辟一块连续的物理空间,链表由两个部分组成,分别为指针域和值域,链表可以利用零散的内存空间存储数据.然后通过指针将这些零散的内存空间连接起来.
3. ### 所以链表拥有灵活的内存分配,以及不用考虑扩容带来的性能消耗,缺点是链表除了存放数据本身的内存开销外,还需要存放指针域的内存开销,所以相较于顺序表链表会额外消耗一部分内存.
4. ### 顺序表的大小在声明时就确定下来了,所以长度已经内存分配的灵活性不高,但是顺序表直接存放数据比较节省内存.并且顺序表支持直接按索引访问元素.即顺序表访问某个元素的时间复杂度为O(1).而链表需要从头结点开始遍历链表,所以它访问元素的时间复杂度为O(n).
5. ### 链表的add方法直接在尾结点处更改指针域的引用即可,任何情况下都不必考虑集合扩容问题.而当顺序表所有的元素空间都被分配完毕时,再想往里面添加元素就必须要考虑扩容的问题.虽然Java数组的拷贝System.arraycopy();方法调用的是本地方法,但其性能开销仍然不容小觑.并且在JDK的默认实现中,扩容的增长因子是1.5,所以扩容往往会造成某些空间不被使用从而造成浪费,而链表就不必担心这种问题.
6. ### 链表和顺序表两者insert方法的时间复杂度都是O(n),链表需要先从头结点遍历到指定元素后进行指针域的修改,顺序表虽然可以直接找到元素位置,但插入完数据后需要把当前插入位置后的所有元素的位置(索引)往后挪一格,所以这一步的时间复杂度也是O(n).
7. ### 链表和顺序表的remove方法.对于链表而言,如果已经获得了要删除索引处的节点,则它的时间复杂度为O(1).而对于顺序表而言无论何时它的remove方法的时间复杂度都是O(n),因为需要将被删除元素后面的所有元素往前挪一位.如果是根据value来进行删除,则两者的时间复杂度都是O(n),相对而言顺序表所需要的时间还会比链表多一些.
8. ### 除了单链表外,还有双链表、循环链表等以单链表为基础的数据结构.
### **<font color="#00FF00">解题思路:</font>**
1. ### 根据本题的题目,可以选择使用单链表或双链表来实现,那这里肯定是选用双链表来实现,因为相较于单链表,双链表在数据查找包括增加和删除都比单链表有天然的优势.唯一的缺点就是增加了实现的复杂度.
2. ### 首先链表是由一个个节点构成的,所以根据面向对象的设计思路,我们需要先定义一个LinkedListNode节点类.
    ```java
    1.private static class LinkedListNode {
    2.    private int value;
    3.    private LinkedListNode next;
    4.    private LinkedListNode pre;
    5.
    6.    public LinkedListNode(int value) {
    7.        this.value = value;
    8.    }
    9.
    10.    public int getValue() {
    11.        return value;
    12.    }
    13.
    14.    public void setValue(int value) {
    15.        this.value = value;
    16.    }
    17.
    18.    public LinkedListNode getNext() {
    19.        return next;
    20.    }
    21.
    22.    public void setNext(LinkedListNode next) {
    23.        this.next = next;
    24.    }
    25.
    26.
    27.    public LinkedListNode getPre() {
    28.        return pre;
    29.    }
    30.
    31.    public void setPre(LinkedListNode pre) {
    32.        this.pre = pre;
    33.    }
    34.}
    ```
3. ### 注意这里定义的实际上是一个静态内部类(也就是LinkedListNode作为一个静态内部类定义在MyLinkedList类中,虽然这里的代码没有体现),由于这个节点类只有当宿主类存在才有意义并且不需要访问宿主类的方法和成员变量,所以这里定义为static类, 关于这里为什么要定义成静态内部类而不是非静态的,在Effect Java这本书中有详细的介绍.详情见:
    ### [Effective Java Third Edition #24. 支持使用静态成员类而不是非静态类.](https://blog.csdn.net/XAVI_2010/article/details/105806091)

4. ### 可以看到这个类的定义非常简单,三个成员变量分别是:value当前节点存储的值,pre上一个节点的引用,next下一个节点的引用.剩下的就是一些构造方法和getter/setter方法.
5. ### 本题看似需要实现5个方法,实际上addAtHead(val)和addAtTail(val)方法就是addAtIndex(0,val)、addAtIndex(size,val)方法的变式.所以我们需要定义一个size变量,这个size就表示当前整个链表有多少个元素个数.于是乎我们便能很容易得到addAtHead()和addAtTail()方法的实现:
    ```java
    // 链表的总长度
    1.private int size = 0;
    1.  public void addAtHead(int val) {
    2.    addAtIndex(0, val);
    3.  }
    5.
    1.  public void addAtTail(int val) {
    2.      addAtIndex(size, val);
    3.  }
    4.    
    5.   public void addAtIndex(int index, int val) {
    6.     //do something...
    7.   }
    ```
6. ### 此外我们还需要定义两个成员变量,一个指向当前链表的头结点,一个指向当前链表的尾结点.并且我们采用的是双链表,双链表的好处是除了可以找后继节点之外,还可以找前驱节点.所以当我们查找某个节点时,可以从头结点往后查找找也可以从尾结点往前查找,具体采用哪种算法取决于要查找的元素的索引位置.假设现在有这样一个链表:
    | index |   0    |   1    |   2    |
    | :---: | :----: | :----: | :----: |
    | list  | value0 | value1 | value2 |
    ### 链表的长度是3,假设现在要访问第0个元素,则肯定从头结点开始遍历查找,假设要访问第2个元素,肯定从尾结点开始遍历查找.但如果此时要访问第1个元素,此时无论是从头结点还是尾结点进行遍历它俩的操作次数都是一样的.于是乎我们先假定当当前访问的索引小于链表长度除以2时就从头结点开始遍历查找,否则从尾结点遍历查找.在这个例子中如果要访问索引1处的元素,则它会从尾结点进行遍历.size/2 = 1.
    ### 那如果条件改成当访问元素的索引小于等于链表长度除以2时就从头结点开始,否则从尾结点开始.因为上面说过这种情况下无论从头结点还是尾结点开始所经过的步骤都一样,那为什么这里不能从头结点开始呢?
    ### 假设现在有个链表为:
    | index |   0    |   1    |
    | :---: | :----: | :----: |
    | list  | value0 | value1 |
    ### 此时如果想要访问元素1,那么因为 size / 2 = 1 按照上面所述,这里会从头结点开始遍历.实际上我们知道此时元素1的位置就是尾结点的位置,应该直接返回尾结点即可.
    ### 综上所述,查找某个元素的逻辑是:当前访问的索引小于链表长度除以2时就从头结点开始遍历查找,否则从尾结点遍历查找.
    ### 这样做的好处上是为了缩短元素的查找时间,因为如果只从链表的一端查找,假设要访问索引为n处的元素,就要从头遍历到末尾要遍历n次.如果从两端遍历,要访问索引为n处的元素,直接返回即可.所以从两端遍历查找元素只需要遍历最多n/2次便可得到目标元素.
    ```java
    1.private LinkedListNode getNodeFromIndex(int index) {
    1.    LinkedListNode current = null;
    2.    if (index < size / 2) {
    3.        current = firstNode;
    4.        for (int i = 0; i < index; i++) {
    5.            current = current.getNext();
    6.        }
    7.    } else {
    8.        current = lastNode;
    9.         for (int i = 0; i < size - index - 1; i++) {
    10.            current = current.getPre();
    11.        }
    12.    }
    13.    return current;
    15.}
    ```
7. ### 于是乎get方法的实现也便浮出水面,注意代码健壮性的判断,详情见:[代码的健壮性](#Robust)
    ```java
    1.public int get(int index) {
    1.    // 无效的索引
    2.    if (index < 0 || index > size - 1) {
    3.        return -1;
    4.    }
    5.    return getNodeFromIndex(index).getValue();
    7.}
    ```
8. ### 关于addAtIndex(int index,int value)方法的实现,根据题意是在某个元素之前插入一个元素.首先插入的索引必须合法,这里不再过多的赘述,详情见:[代码的健壮性](#Robust).
    ### 接着我们必须先找到要在哪个元素之前进行插入操作(称作currentNode).然后我们还必须创建这个新的节点(称作newNode).我们直接将newNode的前一个节点的引用设置为currentNode的前一个节点,再将newNode的后一个节点的引用设置为currentNode.然后将currentNode的前一个节点的引用设置为newNode.判断如果此时newNode的前一个节点(即之前currentNode的前一个节点)不为空,则让newNode的前一个节点的后一个节点引用设置为newNode.否则表明当前newNode就是头结点(因为头结点前没有任何结点,引用自然也为null),所以需要将当前链表的头节点的指针指向newNode.
    ### 另外因为我的实现没有用到虚空节点,所以我还需要对index = size的这种特殊情况做处理(即将元素添加到链表末尾的处理):
    ### 创建新的节点,直接拿到尾结点的指针,将尾结点的下一个节点的引用设为新节点,并将新节点的上一个节点的引用设置尾结点,最后让链表的尾指针指向新节点即可.
    ### 另外如果链表的长度为0代表此时的链表一个元素都没有,如果此时往链表中添加元素,则需要将链表的头指针和尾指针同时指向该元素.
    ### **<p align="center"><font color="#FF0000">图解插入过程:</font></p>**
    <p style="text-align: center;"><img src="resources/InsertLinkedList_1.png"></p>
    <p style="text-align: center;"><img src="resources/InsertLinkedList_2.png"></p>
    <p style="text-align: center;"><img src="resources/InsertLinkedList_3.png"></p>
    <p style="text-align: center;"><img src="resources/InsertLinkedList_4.png"></p>
    <p style="text-align: center;"><img src="resources/InsertLinkedList_5.png"></p>
9. ### 关于deleteAtIndex(int index)方法的实现.首先删除的索引必须合法,这里不再过多的赘述,详情见:[代码的健壮性](#Robust).
     ### 接着我们必须先找到要删除的这个元素,调用getNodeFromIndex()方法得到该元素.
    ### 如果当前要删除的节点的前一个节点为null表明当前节点就是头结点,那就将链表的头结点指向当前节点的下一个节点,否则将当前节点的上一个节点的下一个节点的引用设置为当前节点的下一个节点.
    ### 如果当前要删除的节点的后一个节点为null表明当前节点就是尾结点,那就将链表的头结点指向当前节点的前一个节点,否则将当前节点的下一个节点的上一个节点的引用设置为当前节点的上一个节点.
    ### 另外如果在删除之前链表的长度就为1,我们直接将当前链表的size-1即可.此时相当于重置了整个链表,之后再往链表中添加元素时会重新设置链表的头结点和尾结点的指针.而这种情况下是无法再从链表中移除元素的,因为想从长度为0的链表中移除元素时无法通过代码健壮性(或者叫参数合法性)检查的.
    ### **<p align="center"><font color="#FF0000">图解删除过程:</font></p>**
    <p style="text-align: center;"><img src="resources/DeleteLinkedList_1.png"></p>
    <p style="text-align: center;"><img src="resources/DeleteLinkedList_2.png"></p>
    <p style="text-align: center;"><img src="resources/DeleteLinkedList_3.png"></p>
### **<font color="#00FFFF">代码实现:</font>**
```java
1.class MyLinkedList {
2.    // 链表的总长度
3.    private int size = 0;
4.    // 链表的头结点
5.    private LinkedListNode firstNode;
6.    // 链表的尾结点
7.    private LinkedListNode lastNode;
8.
9.
10.    public MyLinkedList() {
11.
12.    }
13.
14.    public int get(int index) {
15.        // 无效的索引
16.        if (index < 0 || index > size - 1) {
17.            return -1;
18.        }
19.        return getNodeFromIndex(index).getValue();
20.    }
21.
22.    public void addAtHead(int val) {
23.        addAtIndex(0, val);
24.    }
25.
26.    public void addAtTail(int val) {
27.        addAtIndex(size, val);
28.    }
29.
30.    public void addAtIndex(int index, int val) {
31.        // 如果索引大于链表大小,直接返回即可
32.        if (index > size) {
33.            return;
34.        }
35.        // 添加头结点
36.        if (size == 0) {
37.            firstNode = new LinkedListNode(val);
38.            lastNode = firstNode;
39.            size++;
40.            return;
41.        }
42.        LinkedListNode newValue = new LinkedListNode(val);
43.        // 需要单独处理添加尾节点的操作
44.        if (index == size) {
45.            lastNode.setNext(newValue);
46.            newValue.setPre(lastNode);
47.            lastNode = newValue;
48.            size++;
49.            return;
50.        }
51.        // 进行到这一步链表的长度必定>0
52.        LinkedListNode addNode = getNodeFromIndex(index);
53.        newValue.setNext(addNode);
54.        newValue.setPre(addNode.getPre());
55.        addNode.setPre(newValue);
56.        if (newValue.getPre() != null) {
57.            newValue.getPre().setNext(newValue);
58.        } else {
59.            // 如果newValueNext==null则表明,当前的current就是尾节点,那还需要把尾节点赋值给lastNode
60.            firstNode = newValue;
61.        }
62.        size++;
63.    }
64.
65.    public void deleteAtIndex(int index) {
66.        // 无效索引
67.        if (index < 0 || index >= size) {
68.            return;
69.        }
70.        // 链表长度为1时的另外判断
71.        if (size == 1) {
72.            size--;
73.            return;
74.        }
75.        // 进行到这一步,链表的长度必定>1
76.        LinkedListNode deleteNode = getNodeFromIndex(index);
77.
78.        if (deleteNode.getPre() != null) {
79.            deleteNode.getPre().setNext(deleteNode.getNext());
80.        } else {
81.            // 此时要删除的节点为头结点
82.            firstNode = deleteNode.getNext();
83.        }
84.        if (deleteNode.getNext() != null) {
85.            deleteNode.getNext().setPre(deleteNode.getPre());
86.        } else {
87.            // 此时要删除的节点为尾结点
88.            lastNode = deleteNode.getPre();
89.        }
90.        size--;
91.    }
92.
93.    private LinkedListNode getNodeFromIndex(int index) {
94.        LinkedListNode current = null;
95.        if (index < size / 2) {
96.            current = firstNode;
97.            for (int i = 0; i < index; i++) {
98.                current = current.getNext();
99.            }
100.        } else {
101.            current = lastNode;
102.            for (int i = 0; i < size - index - 1; i++) {
103.                current = current.getPre();
104.            }
105.        }
106.        return current;
107.    }
108.
109.    private static class LinkedListNode {
110.        private int value;
111.        private LinkedListNode next;
112.        private LinkedListNode pre;
113.
114.        public LinkedListNode(int value) {
115.            this.value = value;
116.        }
117.
118.        public int getValue() {
119.            return value;
120.        }
121.
122.        public void setValue(int value) {
123.            this.value = value;
124.        }
125.
126.        public LinkedListNode getNext() {
127.            return next;
128.        }
129.
130.        public void setNext(LinkedListNode next) {
131.            this.next = next;
132.        }
133.
134.
135.        public LinkedListNode getPre() {
136.            return pre;
137.        }
138.
139.        public void setPre(LinkedListNode pre) {
140.            this.pre = pre;
141.        }
142.    }
143.}

```
**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:
> > 1. ### get方法的时间复杂度为O(n)
> > 2. ### addAtHead()和addAtTail()方法的时间复杂度都是O(1)
> > 3. ### addAtIndex()方法的时间复杂度为O(n/2) = O(n)
> > 4. ### deleteAtIndex()方法的时间复杂度为O(n/2) = O(n)

> ### 空间复杂度:O(n)
> > 1. ### 链表长度就是元素的个数,空间复杂度为O(n).
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![]()

## <p align="center"><font color="#0000FF">[常用技巧总结](#skill)</font></p>
* ### <a id="Robust">[代码的健壮性:](#skill)</a>
  ### 首先要搞清楚一个问题,什么事鲁棒性?为什么需要代码的健壮性? 
  ### 实际上在编写程序时注重健壮性就是为了代码在遇到特殊输入参数时也能不出错,并适当抛出异常告知函数的调用者,下面通过几个具体的例子来了解.
    1. ### 非空值的判断:
        ```java
        1.    /**
        2.     * 打印int数组中的每个元素
        3.     *
        4.     * @param array int数组
        5.     */
        6.    public void printArray(int[] array) {
        7.        if (array == null || array.length == 0) {
        8.            throw new IllegalArgumentException("parameter [array] should not be null or empty!");
        9.        }
        10.        // do something
        11.    }
        ```
        ### 在这个例子中printArray(int[] array)函数的功能是输出一个int数组中的每个元素.所以该函数的期望参数array不应为null,如果为null则抛出异常.除此之外,如果array数组的长度为0,有时也是一种不被期望的参数(因为该方法不会产生任何执行结果),因此除了对对象本身进行非空判断之外,还需要注意参数的逻辑空值,即参数不为null但参数本身没有任何值.
        ### 这个例子最典型的应用就是判断字符串是否为非空字符串,除了判断字符串是否有地址外,还需要调用字符串的isEmpty方法看是否为非空字符串.
    2. ### 边界值判断:
        ### 这里暂且[707. 设计链表](#Leetcode707)这题作为例子,即链表访问/插入某个节点.
        ### 其实对于边界值最常见的场景是,访问数组下标元素.由于数组下标从0开始,所以如果访问的下标小于0必然是不行的,并且如果访问的大小超出数组的总长度,被称为数组越界也是不可行的.可以看看JDK ArrayList的get方法的实现,如果数组越界访问则会调用Preconditions的outOfBoundsCheckIndex方法并抛出一个数组越界异常,所以我们在写程序时也必须考虑代码的健壮性,对边界值进行判断并做处理.
        ```java
        1.    @HotSpotIntrinsicCandidate
        2.    public static <X extends RuntimeException>
        3.    int checkIndex(int index, int length,
        4.                   BiFunction<String, List<Integer>, X>         oobef) {
        5.        if (index < 0 || index >= length)
        6.            throw outOfBoundsCheckIndex(oobef, index,         length);
        7.        return index;
        8.    }
        ```
        ### 以LeetCode707题为例,对于链表元素的访问肯定也不能数组越界,并且根据题意,如果访问的索引无效则需要返回-1.这其实也就是一种特殊的处理逻辑.而这里所谓的无效索引,实际上就是当访问的元素的索引小于0或者大于当前数组的长度-1.
        ### 本题中详细说明了,插入元素时是在这个元素之前插入一个元素.比如调用addAtIndex(0,value)就是在元素0之前插入一个元素.那假设我想在链表的末尾添加一个元素,如果直接调用addAtIndex(size-1,value)它代表的意思是在末尾节点前添加一个节点.而不是在末尾节点的后面添加一个节点.而你是不可能找到末尾节点的后一个节点然后再在这个节点前添加一个节点从而到达在末尾节点后添加一个节点的目的(这句话虽然很绕口但就是事实,因为你不可能找到一个虚空的节点).所以题目也给出规定了,如果调用addAtIndex(size,value)方法指定的索引是链表的长度,则就在当前链表的尾结点后添加一个新的节点.实际上这也是一种边界值的处理,只不过题目中有明确要求,计算没有明确要求,平常我们在实现算法时也是要特别注意这些点的.
* ### <a id="extraCache">[开辟额外空间的注意事项:](#skill)</a>
  ### 由于Java数组按索引访问的类型是int,所以超出int范围的元素是访问不到的,即Java数组最大长度为Integer.MAX_VALUE - 1 即2^31-1.所以我们在开辟新空间时数组的长度不能超过2^31-1否则就要考虑新的算法.

* ### <a id="HexToBitArray">[得到十进制数的第i位二进制表示:](#skill)</a>
   1. ### 如何获取十进制数的二进制表示的末尾是0还是1?
      ```java
      // 常规套路直接抄模板即可
      int number = 5;
      short bit = number & 1; 
      ```
      ### 原理:
      ### (5)<sub>10</sub>的二进制表示为101,将其与1进行与运算,得到的结果为:
      ### 1&ensp;0&ensp;1
      ### &ensp;&ensp;&ensp;&ensp;1
      ### 一一一
      ### 0&ensp;0&ensp;1
      ### 因为1会高位补0,相当于把十进制数5的二进制表示的高位全部与0进行与运算,得到的结果自然为0.效果类似于高位截取.所以这里只会保留十进制数最后一位的值.
  1. ### 获取十进制数的第i位二进制表示的前要知识就是第一点的内容.获取第i位也非常简单,只要将该书右移i位后再对1进行与运算即可.
      ```java
      // 常规套路直接抄模板即可
      int number = 5;
      short bit = number >> i & 1; 
      ```
      ### 假设获取十进制数5的第1位二进制表示.
      ### 同理5的二进制表示还是101,但此时先将5右移1位,得到的二进制数为10,再将其与1进行与运算便可得到第i位的二进制值.