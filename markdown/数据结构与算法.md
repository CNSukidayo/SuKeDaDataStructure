# 绪论
### &emsp;&emsp;当我们谈论起算法时总是无法脱离数据结构的,实际上数据结构与算法这两者是相辅相成的,只有数据结构才能彰显算法的强大,只有算法才能突出数据结构的魅力!所以除了算法之外我也会对常见的数据结构进行实现.
### <p align="right">一一顾元杰</br>学号:20200135223</br>班级:计算机Z2012</p>

# <a id="list">目录:</a>  

* ### [剑指 Offer 03. 数组中重复的数字](#Offer03)
 
</br>

## <a id="skill">常见技巧总结:</a>  
* ### [代码的健壮性](#Robust)
* ### [开辟额外空间的注意事项](#extraCache)

</br>
  
## <a id="Offer03">[剑指 Offer 03. 数组中重复的数字](#list)</a>  

### **<font color="#FFFF00">题目描述:</font>**
> 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>>示例 1：  
输入：
[2, 3, 1, 0, 2, 5, 3]  
输出：2 或 3  
>  
> >  限制：  
2 <= n <= 100000

### **<font color="#00FF00">解题思路:</font>**
### 1. 根据题目所述,nums数组中所有元素的范围都在[0,n-1]的范围内.于是乎自然相当,可以用一个长度为n的布尔数组contains来存储当前已经出现的元素的真假.用contains数组的索引来对应元素字面值.
### 2.首先初始化contains数组,长度为n.此时contains数组中的每个元素都为false.
### 3.接着遍历nums数组,直接以nums数组中元素的字面值作为contains数组的元素索引,将该索引处的元素值设置为true,以此来代表某个数已经出现过.
### 4.如果在遍历的过程中,发现在设置contains数组的某个元素值为true之前,该元素值已经是true了,那么就表明当前数已经出现过一次,返回即可.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.public int findRepeatNumber(int[] nums) {
2.    if (nums == null || nums.length == 0) {
3.        throw new IllegalArgumentException("parameter should not be null or empty!");
4.    }
5.    boolean[] contains = new boolean[nums.length];
6.    for (int i = 0; i < nums.length; i++) {
7.        if (temp[nums[i]]) {
8.            return nums[i];
9.        }
10.        contains[nums[i]] = true;
11.    }
12.    return 0;
13.}

```
### 1. 首先是代码健壮性的判断.2-4行,关于代码健壮性判断详情见:[代码的健壮性](#Robust)
### 2. 第五行是用于存储已经出现过的元素的状态标识数组.数组的索引映射出现过的元素的字面值.
### 3. 6-11行遍历nums数组,并做相应的操作.

### **<font color="#FF00FF">表格演示:</font>**
### 1. 初始化contains数组,长度为n.
|    ↓     |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  array   |   2   |   3   |   1   |   0   |   2   |   5   |   3   |
| contains |   F   |   F   |   F   |   F   |   F   |   F   |   F   |
### 2. 开始遍历数组
### 将array当前元素的字面值作为contains数组的下标,并将该contains元素设置为true.
|  index   | <strong><font color="#ff00ff">↓</font></strong> |   1   |                        2                        |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|  array   | <strong><font color="#00ff00">2</font></strong> |   3   |                        1                        |   0   |   2   |   5   |   6   |
| contains |                        F                        |   F   | <strong><font color="#00ff00">F</font></strong> |   F   |   F   |   F   |   F   |
### 3. 继续遍历执行
|  index   |                        0                        | <strong><font color="#ff00ff">↓</font></strong> |                        2                        |                        3                        |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                        1                        |                        0                        |   2   |   5   |   6   |
| contains |                        F                        |                        F                        | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#00ff00">F</font></strong> |   F   |   F   |   F   |

### 4. 继续遍历执行
|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |                        3                        |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#00ff00">1</font></strong> |                        0                        |   2   |   5   |   6   |
| contains |                        F                        | <strong><font color="#00ff00">F</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |   T   |   F   |   F   |
### 5. 继续遍历执行
|  index   |                        0                        |                        1                        |                        2                        | <strong><font color="#ff00ff">↓</font></strong> |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">0</font></strong> |   2   |   5   |   6   |
| contains | <strong><font color="#00ff00">F</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |   T   |   F   |   F   |
### 6. 继续遍历执行,直到访问到contains数组某个元素为true时,此时array数组的当前元素就是重复出现过的元素.所以此时2即为重复出现的元素.
|  index   |                        0                        |                        1                        |                        2                        |                        3                        | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">0</font></strong> | <strong><font color="#00ff00">2</font></strong> |   5   |   6   |
| contains | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ff0000">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |                        T                        |   F   |   F   |

**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > ### 假设一种最坏的情况,数组中元素只重复出现一次,例如:[0,1,2,3,...n-1,0],因为需要遍历玩整个数组才知道重复的元素是哪一个,所以时间复杂是O(n).

> ### 空间复杂度:O(n)
> > ### 因为需要一个布尔数组contains数组来存放已经出现过的元素的状态值,并且认定出现过的数作为contains数组的下标,那么要想contains下标合法,所以contains数组的长度就是元素数值的取值范围.即n-1+1=n
> > ### 最后检验,发现给出的条件中有<font color="#FF0000">2<=n<=100000</font>,contains数组大小不超过2^31-1.


## <p align="center"><font color="#0000FF">[常用技巧总结](#skill)</font></p>
* ### <a id="Robust">[代码的健壮性:](#skill)</a>
  ### 首先要搞清楚一个问题,什么事鲁棒性?为什么需要代码的健壮性? 
  ### 实际上在编写程序时注重健壮性就是为了代码在遇到特殊输入参数时也能不出错,并适当抛出异常告知函数的调用者,下面通过几个具体的例子来了解.
    1. ### 非空值的判断:
        ```java
        1.      /**
        2.     * 打印int数组中的每个元素
        3.     *
        4.     * @param array int数组
        5.     */
        6.    public void printArray(int[] array) {
        7.        if (array == null || array.length == 0) {
        8.            throw new IllegalArgumentException("parameter [array] should not be null or empty!");
        9.        }
        10.        // do something
        11.    }
        ```
        ### 在这个例子中printArray(int[] array)函数的功能是输出一个int数组中的每个元素.所以该函数的期望参数array不应为null,如果为null则抛出异常.除此之外,如果array数组的长度为0,有时也是一种不被期望的参数(因为该方法不会产生任何执行结果),因此除了对对象本身进行非空判断之外,还需要注意参数的逻辑空值,即参数不为null但参数本身没有任何值.
        ### 这个例子最典型的应用就是判断字符串是否为非空字符串,除了判断字符串是否有地址外,还需要调用字符串的isEmpty方法看是否为非空字符串.
    2. ### 边界值判断:
* ### <a id="extraCache">[开辟额外空间的注意事项:](#skill)</a>
  ### 由于Java数组按索引访问的类型是int,所以超出int范围的元素是访问不到的,即Java数组最大长度为Integer.MAX_VALUE - 1 即2^31-1.所以我们在开辟新空间时数组的长度不能超过2^31-1否则就要考虑新的算法.