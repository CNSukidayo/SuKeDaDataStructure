# 绪论
### &emsp;&emsp;当我们谈论起算法时总是无法脱离数据结构的,实际上数据结构与算法这两者是相辅相成的,只有数据结构才能彰显算法的强大,只有算法才能突出数据结构的魅力!所以除了算法之外我也会对常见的数据结构进行实现.
### <p align="right">一一顾元杰</br>学号:20200135223</br>班级:计算机Z2012</p>

# 目录:
##### <p align="right">提示:点击题目名称可直接跳转LeetCode</p>
* ### [剑指 Offer 03. 数组中重复的数字](#Offer03)
* ### [剑指 Offer II 004. 只出现一次的数字 ](#Offer04)
 
</br>

## <a id="skill">常见技巧总结:</a>  
* ### [代码的健壮性](#Robust)
* ### [开辟额外空间的注意事项](#extraCache)
* ### [得到十进制数的第i位二进制表示](#HexToBitArray)

</br>
  
## <a id="Offer03">[剑指 Offer 03. 数组中重复的数字](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)</a>  

### **<font color="#FFFF00">题目描述:</font>**
> 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>>示例 1：  
输入：
[2, 3, 1, 0, 2, 5, 3]  
输出：2 或 3  
>  
> >  限制：  
2 <= n <= 100000

### **<font color="#00FF00">解题思路:</font>**
1. ### 根据题目所述,nums数组中所有元素的范围都在[0,n-1]的范围内.于是乎自然相当,可以用一个长度为n的布尔数组contains来存储当前已经出现的元素的真假.用contains数组的索引来对应元素字面值.
2. ### 首先初始化contains数组,长度为n.此时contains数组中的每个元素都为false.
3. ### 接着遍历nums数组,直接以nums数组中元素的字面值作为contains数组的元素索引,将该索引处的元素值设置为true,以此来代表某个数已经出现过.
4. ### 如果在遍历的过程中,发现在设置contains数组的某个元素值为true之前,该元素值已经是true了,那么就表明当前数已经出现过一次,返回即可.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.public int findRepeatNumber(int[] nums) {
2.    if (nums == null || nums.length == 0) {
3.        throw new IllegalArgumentException("parameter should not be null or empty!");
4.    }
5.    boolean[] contains = new boolean[nums.length];
6.    for (int i = 0; i < nums.length; i++) {
7.        if (temp[nums[i]]) {
8.            return nums[i];
9.        }
10.        contains[nums[i]] = true;
11.    }
12.    return 0;
13.}

```
1. ### 首先是代码健壮性的判断.2-4行,关于代码健壮性判断详情见:[代码的健壮性](#Robust)
2. ### 第五行是用于存储已经出现过的元素的状态标识数组.数组的索引映射出现过的元素的字面值.
3. ### 6-11行遍历nums数组,并做相应的操作.

### **<font color="#FF00FF">表格演示:</font>**
1. ### 初始化contains数组,长度为n.
|    ↓     |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  array   |   2   |   3   |   1   |   0   |   2   |   5   |   3   |
| contains |   F   |   F   |   F   |   F   |   F   |   F   |   F   |
2. ### 开始遍历数组
### 将array当前元素的字面值作为contains数组的下标,并将该contains元素设置为true.
|  index   | <strong><font color="#ff00ff">↓</font></strong> |   1   |                        2                        |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|  array   | <strong><font color="#00ff00">2</font></strong> |   3   |                        1                        |   0   |   2   |   5   |   6   |
| contains |                        F                        |   F   | <strong><font color="#00ff00">F</font></strong> |   F   |   F   |   F   |   F   |
3. ### 继续遍历执行
|  index   |                        0                        | <strong><font color="#ff00ff">↓</font></strong> |                        2                        |                        3                        |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                        1                        |                        0                        |   2   |   5   |   6   |
| contains |                        F                        |                        F                        | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#00ff00">F</font></strong> |   F   |   F   |   F   |

4. ### 继续遍历执行
|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |                        3                        |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#00ff00">1</font></strong> |                        0                        |   2   |   5   |   6   |
| contains |                        F                        | <strong><font color="#00ff00">F</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |   T   |   F   |   F   |
5. ### 继续遍历执行
|  index   |                        0                        |                        1                        |                        2                        | <strong><font color="#ff00ff">↓</font></strong> |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">0</font></strong> |   2   |   5   |   6   |
| contains | <strong><font color="#00ff00">F</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |   T   |   F   |   F   |
6. ### 继续遍历执行,直到访问到contains数组某个元素为true时,此时array数组的当前元素就是重复出现过的元素.所以此时2即为重复出现的元素.
|  index   |                        0                        |                        1                        |                        2                        |                        3                        | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: |
|  array   | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">0</font></strong> | <strong><font color="#00ff00">2</font></strong> |   5   |   6   |
| contains | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ffc800">T</font></strong> | <strong><font color="#ff0000">T</font></strong> | <strong><font color="#ffc800">T</font></strong> |                        T                        |   F   |   F   |

**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > ### 假设一种最坏的情况,数组中元素只重复出现一次,例如:[0,1,2,3,...n-1,0],因为需要遍历玩整个数组才知道重复的元素是哪一个,所以时间复杂是O(n).

> ### 空间复杂度:O(n)
> > ### 因为需要一个布尔数组contains数组来存放已经出现过的元素的状态值,并且认定出现过的数作为contains数组的下标,那么要想contains下标合法,所以contains数组的长度就是元素数值的取值范围.即n-1+1=n
> > ### 最后检验,发现给出的条件中有<font color="#FF0000">2<=n<=100000</font>,contains数组大小不超过2^31-1.
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer3.png)

## <a id="Offer04">[剑指 Offer II 004. 只出现一次的数字 ](https://leetcode.cn/problems/WGki4K/)</a>  
### **<font color="#FFFF00">题目描述:</font>**
> ### 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
> ### 示例 1：
> > ### 输入：nums = [2,2,3,2]
> > ### 输出：3
> ### 示例 2：
> > ### 输入：nums = [0,1,0,1,0,1,100]
> > ### 输出：100
> ### 提示：
> > * ### 1 <= nums.length <= 3 * 10<sup>4</sup>
> > * ### -2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1
> > * ### nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
## <p align="center"><font color="#0000FF">解法一之双HashSet</font></p>
### **<font color="#00FF00">解题思路:</font>**
1. ### 在本题给出的条件中,nums数组的每个元素的取值范围为-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1,显然我们不可能按照Offer3那题的方法去创建一个布尔数组标识已经出现过的数的状态,因为nums数组中元素的取值范围太广泛.
2. ### 既然如此,题目中又说除了某个元素外其余的元素都恰好出现三次.显然我们可以通过另一种方式来标识已经出现过的元素.
3. ### 我们解题的核心技术扣住某个元素只出现一次这句话.创建两个HastSet一个称作contains,contains的作用是记录所有出现过元素,即只要某个元素不存在于contains中,那么就将该元素添加到contains集合中.第二个HastSet称作saveSet,saveSet的作用是记录已经出现过的元素,并将重复的元素从saveSet中移除.
4. ### 首先遍历nums数组,将每个元素去contains集合中进行比对看contains集合是否有该元素,如果没有就将该元素添加到contains和saveSet集合中.如果contains元素中有该元素,则能传递两个信息,一是该元素曾经必然出现过,二是saveSet中曾经也必然添加过该元素,于是乎这是一个重复元素将该元素从saveSet中移除.如此操作所有重复出现过的元素到最后必然都不存在于saveSet中,只有那个只出现过一次的元素会存在于saveSet中,最终将该元素返回即刻.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.public class Offer4 {
2.    private Set<Integer> saveSet;
3.    private Set<Integer> contains;
4.
5.    public int singleNumber(int[] nums) {
6.        if (nums == null || nums.length % 3 != 1) {
7.            throw new IllegalArgumentException("nums数组不能为空,并且nums数组的长度取余3必须为1!");
8.        }
9.        saveSet = new HashSet<>(nums.length / 3 + 1);
10.       contains = new HashSet<>(nums.length / 3 + 1);
11.        for (int i = 0; i < nums.length; i++) {
12.            if (!contains.contains(nums[i])) {
13.                contains.add(nums[i]);
14.                saveSet.add(nums[i]);
15.            } else {
16.                saveSet.remove(nums[i]);
17.            }
18.        }
19.        return saveSet.iterator().next();
20.    }
21.}
```
1. ### 首先6-8行是代码健壮性的判断,详情见:[代码的健壮性.](#Robust)另外值得注意的一点是,这里数组的长度取模3的值一定是1,因为除某个元素只出现一次外,其余的每个元素都恰好出现三次.
2. ### 9-10行对HashSet进行初始化,并且指定集合大小,saveSet指定为nums.length / 3 + 1,具体为什么是这个值的原因不在过多阐述.提前指定集合大小的好处是避免HastSet的自动扩容造成的时间和空间上的浪费.
3. ### 接着就是遍历nums数组,并按照解题思路中的思路编码即可.
4. ### 最后一步返回结果的时候,因为此时saveSet中必然只剩下一个元素(即只出现一次的元素),所以直接用迭代器返回第一个元素即刻.
### **<font color="#FF00FF">表格演示:</font>**
1. ### 以nums = [1,2,1,3,2,1,2]举例

2. ### 初始化HastSet
|  index   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   nums   |   1   |   2   |   1   |   3   |   2   |   1   |   2   |
| contains |       |       |       |       |       |       |       |
| saveSet  |       |       |       |       |       |       |       |

3. ### 开始遍历数组,并且在contains集合中进行判断看是否存在当前元素,如果不存在就将当前元素添加到contains和saveSet集合中去.
|  index   | <strong><font color="#ff00ff">↓</font></strong> |   1   |   2   |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---: | :---: | :---: | :---: | :---: | :---: |
|   nums   | <strong><font color="#00ff00">1</font></strong> |   2   |   1   |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#00ff00">1</font></strong> |       |       |       |       |       |       |
| saveSet  | <strong><font color="#00ff00">1</font></strong> |       |       |       |       |       |       |

4. ### 继续遍历
|  index   |                        0                        | <strong><font color="#ff00ff">↓</font></strong> |   2   |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        | <strong><font color="#00ff00">2</font></strong> |   1   |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> |       |       |       |       |       |
| saveSet  | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> |       |       |       |       |       |
5. ### 继续遍历,一旦发现contains数组中存在当前元素,那么就将当前元素从saveSet集合中移除.
|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        | <strong><font color="#00ff00">1</font></strong> |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#ffc800">2</font></strong> |                                                 |       |       |       |       |
| saveSet  | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#ffc800">2</font></strong> |                                                 |       |       |       |       |

|  index   |                        0                        |                        1                        | <strong><font color="#ff00ff">↓</font></strong> |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        | <strong><font color="#00ff00">1</font></strong> |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> |                                                 |       |       |       |       |
| saveSet  | <strong><font color="#ffc800">2</font></strong> |                                                 |                                                 |       |       |       |       |
6. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        | <strong><font color="#ff00ff">↓</font></strong> |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        | <strong><font color="#00ff00">3</font></strong> |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                                                 |       |       |       |
| saveSet  | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |                                                 |                                                 |       |       |       |
7. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        |   3   | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   | <strong><font color="#00ff00">2</font></strong> |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |                                                 |       |       |
| saveSet  | <strong><font color="#00ff00">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |                                                 |       |                                                 |       |       |

|  index   |                        0                        |                        1                        |                        2                        |   3   | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   | <strong><font color="#00ff00">2</font></strong> |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |                                                 |       |       |
| saveSet  | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |                                                 |       |       |

8. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        |   3   |   4   | <strong><font color="#ff00ff">↓</font></strong> |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---------------------------------------------: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   |   2   | <strong><font color="#00ff00">1</font></strong> |   2   |
| contains | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |       |                                                 |       |
| saveSet  | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |       |                                                 |       |

9. ### 继续遍历
|  index   |                        0                        |                        1                        |                        2                        |   3   |   4   |   5   | <strong><font color="#ff00ff">↓</font></strong> |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---------------------------------------------: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   |   2   |   1   | <strong><font color="#00ff00">2</font></strong> |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#00ff00">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |       |       |                                                 |
| saveSet  | <strong><font color="#ffc800">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |       |       |                                                 |
 
10. ### 遍历结束后将saveSet中的第一个元素(也就是唯一的一个元素)返回即可.
|  index   |                        0                        |                        1                        |                        2                        |   3   |   4   |   5   |   6   |
| :------: | :---------------------------------------------: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: |
|   nums   |                        1                        |                        2                        |                        1                        |   3   |   2   |   1   |   2   |
| contains | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">2</font></strong> | <strong><font color="#ffc800">3</font></strong> |       |       |       |       |
| saveSet  | <strong><font color="#ff0000">3</font></strong> | <strong><font color="#ffc800"></font></strong>  |                                                 |       |       |       |       |


**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > 1. ### 首先需要遍历整个nums数组,所以时间复杂度为O(n)
> > 2. ### 其次每次都要对元素进行contains判断,根据主流说法,HashSet的时间复杂度为O(1).
> > 3. ### contains被判为false一共只会出现nums.length/3+1次,当contains判为false时会进行两次add操作,分别将当前元素添加到contains和saveSet这两个集合中去,根据主流说法HashSet的add方法时间复杂度为O(1),所以contains被判为false时会执行O(1)+O(1)的时间复杂度的代码.
> > 4. ### contains被判为true一共会出现num.length / 3 * 2次,当contains判为true时会对saveSet进行remove操作,根据主流说法HashSet的remove方法时间复杂度为O(1).
> > 5. ### 所以综上所述时间复杂度为:O(n*(O(1) + n / 3 + 1 * (O(1)+O(1)) + n / 3 * 2 * O(1))) = O(n)

> ### 空间复杂度:O(n)
> > 1. ### 需要两个HashSet,其中contains这个集合的大小为O(n / 3 + 1),因为不管给定的nums内的元素如何排列,contains集合代表的意义是已经出现过的元素的集合.而所有元素出现的次数必定是nums数组的总长度除3再加1.
> > 2. ### 同理saveSet集合也不会存储重复出现过的元素,所以它的长度最大也是nums数组的长度除3再加1.即O(n / 3 + 1)
> > 3. ### 综上所述空间复杂度为: O(n / 3 + 1) + O(n / 3 + 1) = O(n)

### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer4_1.png)

## <p align="center"><font color="#0000FF">解法二之排序</font></p>
### **<font color="#00FF00">解题思路:</font>**
1. ### 如题所述,解题核心是紧扣每个元素都恰好出现三次.
2. ### 我们先假设nums数组中的每个元素都恰好出现三次,此时对该数组进行排序后,应当形成每三个元素为一组的局面.每组元素都相同.若此时往该有序数组中插入一个未出现过的元素,那么这个元素出现的位置只也两种可能.第一种可能是出现在某组之前,另外一种可能是出现在nums数组的最后一个位置.
3. ### 看第一种情况,假设 nums = [1,3,1,3,1,3,2] 将其排序后 nums = [1,1,1,2,3,3,3].
4. ### 再看一种情况,假设 nums = [1,2,1,2,1,2,3] 将其排序后 nums = [1,1,1,2,2,2,3].
5. ### 所以我们只要每三个元素为一组进行遍历,遍历时判断每组的第一个和第二个元素是否相等,如果这两个元素不相等,那么该组中的第一个元素就是只出现一次的元素.对于第二种情况,如果遍历到最后只剩下一个元素时还没有找到只出现一次的元素,那么最后一个元素必为只出现一次的元素.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.class Solution {
2.    public int singleNumber(int[] nums) {
3.        if (nums == null || nums.length % 3 != 1) {
4.            throw new IllegalArgumentException("nums数组不能为空,并且nums数组的长度取余3必须为1!");
5.        }
6.        Arrays.sort(nums);
7.        for (int i = 0; i < nums.length - 1; i += 3) {
8.            if (nums[i] != nums[i + 1]) {
9.                return nums[i];
10.            }
11.        }
12.        return nums[nums.length - 1];
13.    }
14.}
```
1. ### 首先6-8行是代码健壮性的判断,详情见:[代码的健壮性.](#Robust)另外值得注意的一点是,这里数组的长度取模3的值一定是1,因为除某个元素只出现一次外,其余的每个元素都恰好出现三次.
2. ### 接着调用Arrays.sort()对nums数组进行排序.
3. ### 按照一开始的思路,对排序后的nums数组以三个元素为一组,对每组的第一个和第二个元素进行值相等的比较.
4. ### 如果for循环结束还没有找到只出现一次的数值,那么就将数组最后一个元素进行返回.
### **<font color="#FF00FF">表格演示:</font>**
1. ### 初始化表格
| index |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| nums  |   1   |   3   |   1   |   3   |   1   |   3   |   2   |
2. ### 对nums数组进行排序
| index |   0   |   1   |   2   |   3   |   4   |   5   |   6   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| nums  |   1   |   1   |   1   |   2   |   3   |   3   |   3   |
3. ### 以三个元素为一组开始遍历,并比较第一个元素和第二个元素是否相等.
| index | <strong><font color="#ff00ff">↓</font></strong> | <strong><font color="#ff00ff">↓</font></strong> |   2   |   3   |   4   |   5   |   6   |
| :---: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: | :---: | :---: | :---: |
| nums  | <strong><font color="#00ff00">1</font></strong> | <strong><font color="#00ff00">1</font></strong> |   1   |   2   |   3   |   3   |   3   |
4. ### 如果发现不相等,则返回改组中的第一个元素,注意因为是以三个元素为一组所以不会对索引2除的元素进行任何操作.这里发现2!=3所以返回2即刻.
| index |                        0                        |                        1                        |   2   | <strong><font color="#ff00ff">↓</font></strong> | <strong><font color="#ff00ff">↓</font></strong> |   5   |   6   |
| :---: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---------------------------------------------: | :---------------------------------------------: | :---: | :---: |
| nums  | <strong><font color="#ffc800">1</font></strong> | <strong><font color="#ffc800">1</font></strong> |   1   | <strong><font color="#ff0000">2</font></strong> | <strong><font color="#00ff00">3</font></strong> |   3   |   3   |
**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n log(n))
> > 1. ### 首先第一步就是对nums数组进行排序,根据JDK官方的API说法是该算法在大多数情况下的时间复杂度都是O(n log(n)),所以对nums数组进行排序的时间复杂度为O(n log(n)).
> > 2. ### 其次是以三个元素为一组进行比较,一共会执行 n / 3次,所以比较数值这一步的时间复杂度为O(n / 3)
> > 3. ### 综上所述,算法的时间复杂度为O(n log(n))
> ### 空间复杂度:O(1)
> > 1. ### 本算法不需要开辟额外的内存空间,所以空间复杂度为O(1),即本算法所消耗的空间大小不随问题规模的扩大而扩大.
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer4_2.png)

## <p align="center"><font color="#0000FF">解法三之位运算</font></p>

### **<font color="#00FF00">解题思路:</font>**
1. ### 上述两种算法都各有优劣,一个时间复杂度相对较低,一个空间复杂度相对较低.
2. ### 看了一眼这题的标签是位运算,那么就想想能否用位运算来优化这道题的算法.
3. ### 假设nums = [5,5,5] 这是一个每个元素重复出现三次的数组,它们的二进制分别是:
   ### 1 0 1</br> 
   ### 1 0 1</br>
   ### 1 0 1</br>
   ### 将这三个二进制的每一位想加,得到的二进制是3 0 3 我们对每一位取模3,得到的结果就是 0 0 0.
4. ### 假设nums = [5,5,5,3] 它们的二进制分别为:
   ### 1 0 1</br>
   ### 1 0 1</br>
   ### 1 0 1</br>
   ### &emsp;1 1</br>
   ### 将这四个二进制的每一位想加,得到的二进制是 3 1 4 同样对每一位进行取模3,得到的结果就是 0 1 1 此时不难发现该结果就是只出现一次元素的二进制值.
5. ### 会产生这种情况得益于数组中很多元素都是成3重复出现的,所以它们的二进制也会存在某种相似性(或者叫对称性),导致将它们的二进制表示想加后再取模3结果一定是0.而唯有那个只出现一次的元素的二进制值是显得突兀的.
6. ### 根据题目的提示,数组元素的取值范围为-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1 也就是说会出现负数的情况.而在Java中基本数据类型都是有符号的,并且最高位为符号位.0代表正数1代表负数,所以在相加每个数的二进制时通常要考虑符号位的问题.而这里由于负数和正数的符号位也存在一种对称的关系(即负数和正数出现的次数一定能被3整除,不包含只出现一次的数).简单来说就是这里只要把所有数的二进制想加即可.
7. ### 首先,我们要创建一个长度为32的short数组(称为plus),数组元素从0到32(0->32)依次表示十进制数的二进制从最高位到最低位.假设我们要讲十进制数3存入到plus数组中,它应该是这样的:
    | index |   0   |   1   | 2...29 |  30   |  31   |
    | :---: | :---: | :---: | :----: | :---: | :---: |
    | plus  |   0   |   0   | 0...0  |   1   |   1   |
    ### 值得注意的是将十进制数的二进制表示存储到plus数组中时要注意索引位置不是从0开始存储,而是从数组最后一个元素往前存储.
    ### 另外short类型也有讲究,因为这题给定nums数组的长度范围是<font color="#FF0000">1 <= nums.length <= 3 * 10^4</font>,所以就算nums数组中所有数的某一位二进制都是1,那么在这一位上一共也就是想加30000次,是在short类型的范围之内的.
8. ### 现在开始遍历nums数组,并拿到一个十进制元素.那么该如何将这个十进制元素的二进制表示,存放到plus数组中呢?换句话说就是如何得到十进制数的二进制表示的每一位的值?详情见:[得到十进制数的第i位二进制表示](#HexToBitArray)
9. ### 遍历完数组之后,就是将plus数组中的每个元素对3进行取模,取模后得到的数组就表示只出现一次的那个元素的二进制表示.最后一步就是将二进制数组转为十进制数,我们只要定义一个变量result,然后遍历plus数组将result每次都加等于plus元素的数组再讲其左移1位往复循环便可得到该二进制数组的十进制表示.
### **<font color="#00FFFF">代码实现:</font>**
```java
1.class Solution {
2.    int[] plus = new int[32];
3.
4.    public int singleNumber(int[] nums) {
5.        if (nums == null || nums.length % 3 != 1) {
6.            throw new IllegalArgumentException("nums数组不能为空,并且nums数组的长度取余3必须为1!");
7.        }
8.        for (int i = 0; i < nums.length; i++) {
9.            int currentNumber = nums[i];
10.            for (int j = plus.length - 1; j > -1; j--) {
11.                if (currentNumber != 0) {
12.                    plus[j] += 1 & currentNumber;
13.                    currentNumber >>= 1;
14.                } else {
15.                    break;
16.                }
17.            }
18.        }
19.        for (int i = 0; i < plus.length; i++) {
20.            plus[i] %= 3;
21.        }
22.        int result = 0;
23.        for (int i = 0; i < plus.length; i++) {
24.            result <<= 1;
25.            result += plus[i];
26.        }
27.        return result;
28.    }
29.}
```
1. ### 第2行定义plus数组,长度为32因为int类型是4字节32位的,这里既然要用数组来表示每一位二进制,自然长度为32.
2. ### 5-7行依旧时代码健壮性的判断,详情见:[代码的健壮性.](#Robust)
3. ### 8-18行遍历nums数组并将每一位添加到plus数组中.
4. ### 19-21行,将plus数组的每一位取模3
5. ### 将二进制数组plus转为十进制数值.
### **<font color="#FF00FF">表格演示:</font>**
1. ### 初始化表格,假设nums = [1,-2,3,1,-2,-2,1]
|index|0|1|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|1|-2|3|1|-2|-2|1|
|plus index|0|1|2...27|28|29|30|31|
|plus|0|0|0|0|0|0|0|
2. ### 开始遍历数组,得到第一个元素1的二进制值为1
|index|<strong><font color="#ff00ff">↓</font></strong>|1|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|<strong><font color="#00ff00">1</font></strong>|-2|3|1|-2|-2|1|
|plus index|0|1|2...27|28|29|30|<strong><font color="#00ff00">31</font></strong>|
|plus|0|0|0|0|0|0|<strong><font color="#00ff00">1</font></strong>|
3. ### 继续遍历数组,第二个元素-2的二进制值为1000......10注意这里是负数.
|index|0|<strong><font color="#ff00ff">↓</font></strong>|2|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|1|<strong><font color="#00ff00">-2</font></strong>|3|1|-2|-2|1|
|plus index|<strong><font color="#00ff00">0</font></strong>|1|2...27|28|29|<strong><font color="#00ff00">30</font></strong>|<strong><font color="#ffc800">31</font></strong>|
|plus|<strong><font color="#00ff00">1</font></strong>|0|0|0|0|1|<strong><font color="#ffc800">1</font></strong>|
4. ### 继续遍历数组,第三个元素3的二进制值为11
|index|0|1|<strong><font color="#ff00ff">↓</font></strong>|3|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|1|-2|<strong><font color="#00ff00">3</font></strong>|1|-2|-2|1|
|plus index|<strong><font color="#ffc800">0</font></strong>|1|2...27|28|29|<strong><font color="#00ff00">30</font></strong>|<strong><font color="#00ff00">31</font></strong>|
|plus|<strong><font color="#ffc800">1</font></strong>|0|0|0|0|<strong><font color="#00ff00">2</font></strong>|<strong><font color="#00ff00">2</font></strong>|
5. ### 继续遍历,第四个元素1的二进制值为1
|index|0|1|2|<strong><font color="#ff00ff">↓</font></strong>|4|5|6|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|1|-2|3|<strong><font color="#00ff00">1</font></strong>|-2|-2|1|
|plus index|<strong><font color="#ffc800">0</font></strong>|1|2...27|28|29|<strong><font color="#ffc800">30</font></strong>|<strong><font color="#00ff00">31</font></strong>|
|plus|<strong><font color="#ffc800">1</font></strong>|0|0|0|0|<strong><font color="#ffc800">2</font></strong>|<strong><font color="#00ff00">3</font></strong>|
6. ### 继续遍历直到最后一个元素
|index|0|1|2|3|4|5|<strong><font color="#ff00ff">↓</font></strong>|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|1|-2|3|1|-2|-2|<strong><font color="#00ff00">1</font></strong>|
|plus index|<strong><font color="#ffc800">0</font></strong>|1|2...27|28|29|<strong><font color="#ffc800">30</font></strong>|<strong><font color="#00ff00">31</font></strong>|
|plus|<strong><font color="#ffc800">3</font></strong>|0|0|0|0|<strong><font color="#ffc800">4</font></strong>|<strong><font color="#00ff00">4</font></strong>|
7. ### 对plus数组的每个元素对3进行取模.
|index|0|1|2|3|4|5|<strong><font color="#ff00ff">↓</font></strong>|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|nums|1|-2|3|1|-2|-2|<strong><font color="#00ff00">1</font></strong>|
|plus index|<strong><font color="#00ff00">0</font></strong>|1|2...27|28|29|<strong><font color="#00ff00">30</font></strong>|<strong><font color="#00ff00">31</font></strong>|
|plus|<strong><font color="#ff0000">0</font></strong>|<strong><font color="#ff0000">0</font></strong>|<strong><font color="#ff0000">0</font></strong>|<strong><font color="#ff0000">0</font></strong>|<strong><font color="#ff0000">0</font></strong>|<strong><font color="#ff0000">1</font></strong>|<strong><font color="#ff0000">1</font></strong>|
8. ### 将plus二进制数组转为十进制,最终的结果即为3是只出现一次的元素.

**<font color="#FFC800">复杂度分析:</font>**
> ### 时间复杂度:O(n)  
> > 1. ### 首选需要遍历整个数组,并且对于数组的每个元素还要做32次的位运算(为了获取当前十进制数的二进制表示而做的运算),即时间复杂度为O(n*32)
> > 2. ### 遍历完nums数组后,还需要将当前plus数组的每一位元素对3进行取模,而plus数组的长度固定为32.所以时间复杂度为O(32)
> > 3. ### 最后还需要将plus数组再遍历一次,为的是将二进制数组转为十进制表示.所以时间复杂度也是O(32)
> > 4. ### 综上所述,时间复杂度为O(n * 32) + O(32) + O(32) = O(n) 
> ### 空间复杂度:O(1)
> > 1. ### 只开辟了一个长度固定为32的short数组,作为二进制数的存储.即空间复杂度为O(32) = O(1) 即算法的空间复杂度不随问规模的扩大而扩大.
### **<p align="center"><font color="#FF0000">通过截图:</font></p>**
![](resources/offer4_3.png)

## <p align="center"><font color="#0000FF">[常用技巧总结](#skill)</font></p>
* ### <a id="Robust">[代码的健壮性:](#skill)</a>
  ### 首先要搞清楚一个问题,什么事鲁棒性?为什么需要代码的健壮性? 
  ### 实际上在编写程序时注重健壮性就是为了代码在遇到特殊输入参数时也能不出错,并适当抛出异常告知函数的调用者,下面通过几个具体的例子来了解.
    1. ### 非空值的判断:
        ```java
        1.    /**
        2.     * 打印int数组中的每个元素
        3.     *
        4.     * @param array int数组
        5.     */
        6.    public void printArray(int[] array) {
        7.        if (array == null || array.length == 0) {
        8.            throw new IllegalArgumentException("parameter [array] should not be null or empty!");
        9.        }
        10.        // do something
        11.    }
        ```
        ### 在这个例子中printArray(int[] array)函数的功能是输出一个int数组中的每个元素.所以该函数的期望参数array不应为null,如果为null则抛出异常.除此之外,如果array数组的长度为0,有时也是一种不被期望的参数(因为该方法不会产生任何执行结果),因此除了对对象本身进行非空判断之外,还需要注意参数的逻辑空值,即参数不为null但参数本身没有任何值.
        ### 这个例子最典型的应用就是判断字符串是否为非空字符串,除了判断字符串是否有地址外,还需要调用字符串的isEmpty方法看是否为非空字符串.
    2. ### 边界值判断:
* ### <a id="extraCache">[开辟额外空间的注意事项:](#skill)</a>
  ### 由于Java数组按索引访问的类型是int,所以超出int范围的元素是访问不到的,即Java数组最大长度为Integer.MAX_VALUE - 1 即2^31-1.所以我们在开辟新空间时数组的长度不能超过2^31-1否则就要考虑新的算法.

* ### <a id="HexToBitArray">[得到十进制数的第i位二进制表示:](#skill)</a>
   1. ### 如何获取十进制数的二进制表示的末尾是0还是1?
      ```java
      // 常规套路直接抄模板即可
      int number = 5;
      short bit = number & 1; 
      ```
      ### 原理:
      ### (5)<sub>10</sub>的二进制表示为101,将其与1进行与运算,得到的结果为:
      ### 1&ensp;0&ensp;1
      ### &ensp;&ensp;&ensp;&ensp;1
      ### 一一一
      ### 0&ensp;0&ensp;1
      ### 因为1会高位补0,相当于把十进制数5的二进制表示的高位全部与0进行与运算,得到的结果自然为0.效果类似于高位截取.所以这里只会保留十进制数最后一位的值.
  2. ### 获取十进制数的第i位二进制表示的前要知识就是第一点的内容.获取第i位也非常简单,只要将该书右移i位后再对1进行与运算即可.
      ```java
      // 常规套路直接抄模板即可
      int number = 5;
      short bit = number >> i & 1; 
      ```
      ### 假设获取十进制数5的第1位二进制表示.
      ### 同理5的二进制表示还是101,但此时先将5右移1位,得到的二进制数为10,再将其与1进行与运算便可得到第i位的二进制值.